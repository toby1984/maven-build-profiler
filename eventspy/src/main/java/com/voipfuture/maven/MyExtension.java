package com.voipfuture.maven;

import org.apache.maven.artifact.Artifact;
import org.apache.maven.eventspy.AbstractEventSpy;
import org.apache.maven.eventspy.EventSpy;
import org.apache.maven.execution.ExecutionEvent;
import org.apache.maven.execution.MavenSession;
import org.apache.maven.plugin.MojoExecution;
import org.apache.maven.project.MavenProject;
import org.codehaus.plexus.component.annotations.Component;
import org.codehaus.plexus.logging.LogEnabled;
import org.codehaus.plexus.logging.Logger;

import javax.inject.Named;
import javax.inject.Singleton;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;

@Named("track-build-times")
@Singleton
@Component(role = EventSpy.class, hint = "profiler", description = "Measure times taken by Maven.")
public class MyExtension extends AbstractEventSpy implements LogEnabled
{
    private static final ThreadLocal<Long> start = new ThreadLocal<>();

    private final List<ExecutionRecord> records = new ArrayList<>();

    private Logger log;

    @Override
    public void enableLogging(Logger logger)
    {
        this.log = logger;
    }

    private record ExecutionRecord(String groupId, String artifact, String version, String phase, long executionTimeMillis) {}

    @Override
    public void close() throws Exception
    {
        if ( buildTimeTrackingServerUrl != null ) {
            // TODO: send result to server
            final String json = getJSONRequest(records);
            System.out.println( "\n" + json );
        } else {
            log.error( "ERROR - no server URL configured" );
        }
    }

    private final AtomicBoolean initialized = new AtomicBoolean( false );

    private volatile String buildTimeTrackingProfileId;
    private volatile String buildTimeTrackingServerUrl;

    private volatile boolean enabled = true;

    private void init(MavenProject currentProject, MavenProject topLevelProject)
    {
        if ( initialized.compareAndSet( false,true ) )
        {
            final Function<String,Optional<String>> properties = key ->
            {
                String value = currentProject.getProperties().getProperty( key, null );
                if ( isBlank( value ) )
                {
                    value = topLevelProject.getProperties().getProperty( key, null );
                }
                return isBlank( value ) ? Optional.empty() : Optional.of( value );
            };
            buildTimeTrackingServerUrl =
                properties.apply( "buildTimeTrackingServerUrl" ).orElseThrow( missingPropertyException( "buildTimeTrackingServerUrl" ) );

            buildTimeTrackingProfileId = properties.apply( "buildTimeTrackingProfileId" ).orElse( null );
            if ( buildTimeTrackingProfileId != null ) {
                // probably enough to check the top-level project only...but who knows....
                this.enabled =
                    currentProject.getActiveProfiles().stream().anyMatch( p -> p.getId().equals( buildTimeTrackingProfileId ) ) ||
                    topLevelProject.getActiveProfiles().stream().anyMatch( p -> p.getId().equals( buildTimeTrackingProfileId ) );

                if ( enabled )
                {
                    log.debug( "Profile '" + buildTimeTrackingProfileId + "' is active, will track build execution times" );
                } else {
                    log.debug( "Profile '" + buildTimeTrackingProfileId + "' is NOT active, will NOT track build execution times" );
                }
            } else {
                log.debug( "No specific profile ID tied to build execution time tracking, will always track times." );
            }
        }
    }

    private static boolean isBlank(String s) {
        return s == null || s.isBlank();
    }

    private static Supplier<Error> missingPropertyException(String propertyKey ) {
        // need to throw JVM error as Maven swallows all regular exceptions
        // generated by an EventSpy implementation
        return () -> new Error( "pom.xml lacks configuration for property '" + propertyKey + "'" );
    }

    @Override
    public void onEvent(Object event)
    {
        if ( enabled && event instanceof ExecutionEvent r)
        {
            final MavenSession session = r.getSession();
            if ( session != null &&
                 session.getTopLevelProject() != null &&
                 session.getCurrentProject() != null &&
                ! initialized.get() )
            {
                init( session.getTopLevelProject(), session.getCurrentProject() );
            }

            final MojoExecution exec = r.getMojoExecution();
            String phase = "n/a";
            if ( exec != null )
            {
                phase = exec.getLifecyclePhase();
            }
            switch( r.getType() )
            {
                case MojoStarted -> start.set( System.currentTimeMillis() );
                case MojoSucceeded ->
                {
                    final long elapsedMillis = System.currentTimeMillis() - start.get();
                    final Artifact a = r.getProject().getArtifact();
                    synchronized( records ) {
                        records.add( new ExecutionRecord( a.getGroupId(), a.getArtifactId(), a.getVersion(), phase, elapsedMillis ) );
                    }
                }
            }
        }
    }

    private static String getJSONRequest(List<ExecutionRecord> records)
    {
        final StringBuilder json = new StringBuilder();

        json.append( "{" );
        json.append( "\"buildStartTime\"" ).append( " : " ).append( System.currentTimeMillis() ).append( ", " );
        json.append( "\"records\"" ).append( " : [ " ); // start records

        final Map<String, List<ExecutionRecord>> list = records.stream().collect( Collectors.groupingBy( x -> x.groupId + ":" + x.artifact + ":" + x.version ) );

        for ( Iterator<List<ExecutionRecord>>  it = list.values().iterator() ; it.hasNext() ;  )
        {
            final List<ExecutionRecord> value = it.next();
            if ( value.size() > 0 )
            {
                ExecutionRecord record = value.get( 0 );
                json.append( "{ " );
                json.append( "\"groupId\" : " ).append( jsonString( record.groupId ) ).append( ", " );
                json.append( "\"artifactId\" : " ).append( jsonString( record.artifact ) ).append( ", " );
                json.append( "\"version\" : " ).append( jsonString( record.version ) ).append( ", " );
                json.append( "\"executionTimesByPhase\" : {" );

                for ( Iterator<ExecutionRecord> iterator = value.iterator(); iterator.hasNext(); )
                {
                    record = iterator.next();
                    json.append( jsonString( record.phase ) ).append( " : " ).append( record.executionTimeMillis );
                    if ( iterator.hasNext() )
                    {
                        json.append( ", " );
                    }
                }
                json.append( "}" ); // end executionTimesByPhase
                json.append( "}" ); // end record

                if ( it.hasNext() ) {
                    json.append( ", " );
                }
            }
        }

        json.append( "]" ); // end records
        json.append( "}" );
        return json.toString();
    }

    private static String jsonString(String input)
    {
        if ( input == null )
        {
            return "null";
        }
        else if ( input.isBlank() )
        {
            return '"' + input + '"';
        }
        final char[] array = input.toCharArray();
        final StringBuilder result = new StringBuilder(array.length);
        for ( char c : array )
        {
            switch( c )
            {
                case '\\' -> result.append( "\\\\" );
                case '"' -> result.append( "\\" );
                case '\f' -> result.append( "\\f" );
                case '\b' -> result.append( "\\b" );
                case '\t' -> result.append( "\\t" );
                case '\r' -> result.append( "\\r" );
                case '\n' -> result.append( "\\n" );
                default -> result.append( c );
            }
        }
        return '"' + result.toString() + '"';
    }

    public static void main(String[] args)
    {
        final List<ExecutionRecord> list = List.of(
            new ExecutionRecord( "group", "artifact", "1.0-SNAPSHOT", "clean", 23 ),
            new ExecutionRecord( "group", "artifact", "1.0-SNAPSHOT", "compile", 25 )
            );
        final String json = getJSONRequest( list );
        System.out.println(json);
    }
}